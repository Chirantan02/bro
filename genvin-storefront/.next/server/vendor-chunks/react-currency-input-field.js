"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-currency-input-field";
exports.ids = ["vendor-chunks/react-currency-input-field"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-currency-input-field/dist/index.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-currency-input-field/dist/index.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   formatValue: () => (/* binding */ formatValue)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\n\n/**\n * Escape regex char\n *\n * See: https://stackoverflow.com/questions/17885855/use-dynamic-variable-string-as-regex-pattern-in-javascript\n */\nvar escapeRegExp = function (stringToGoIntoTheRegex) {\n    return stringToGoIntoTheRegex.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n};\n\nvar abbrMap = { k: 1000, m: 1000000, b: 1000000000 };\n/**\n * Parse a value with abbreviation e.g 1k = 1000\n */\nvar parseAbbrValue = function (value, decimalSeparator) {\n    if (decimalSeparator === void 0) { decimalSeparator = '.'; }\n    var reg = new RegExp(\"(\\\\d+(\" + escapeRegExp(decimalSeparator) + \"\\\\d*)?)([kmb])$\", 'i');\n    var match = value.match(reg);\n    if (match) {\n        var digits = match[1], abbr = match[3];\n        var multiplier = abbrMap[abbr.toLowerCase()];\n        return Number(digits.replace(decimalSeparator, '.')) * multiplier;\n    }\n    return undefined;\n};\n\n/**\n * Remove group separator from value eg. 1,000 > 1000\n */\nvar removeSeparators = function (value, separator) {\n    if (separator === void 0) { separator = ','; }\n    var reg = new RegExp(escapeRegExp(separator), 'g');\n    return value.replace(reg, '');\n};\n\n/**\n * Remove invalid characters\n */\nvar removeInvalidChars = function (value, validChars) {\n    var chars = escapeRegExp(validChars.join(''));\n    var reg = new RegExp(\"[^\\\\d\" + chars + \"]\", 'gi');\n    return value.replace(reg, '');\n};\n\n/**\n * Remove prefix, separators and extra decimals from value\n */\nvar cleanValue = function (_a) {\n    var value = _a.value, _b = _a.groupSeparator, groupSeparator = _b === void 0 ? ',' : _b, _c = _a.decimalSeparator, decimalSeparator = _c === void 0 ? '.' : _c, _d = _a.allowDecimals, allowDecimals = _d === void 0 ? true : _d, _e = _a.decimalsLimit, decimalsLimit = _e === void 0 ? 2 : _e, _f = _a.allowNegativeValue, allowNegativeValue = _f === void 0 ? true : _f, _g = _a.disableAbbreviations, disableAbbreviations = _g === void 0 ? false : _g, _h = _a.prefix, prefix = _h === void 0 ? '' : _h, _j = _a.transformRawValue, transformRawValue = _j === void 0 ? function (rawValue) { return rawValue; } : _j;\n    var transformedValue = transformRawValue(value);\n    if (transformedValue === '-') {\n        return transformedValue;\n    }\n    var abbreviations = disableAbbreviations ? [] : ['k', 'm', 'b'];\n    var reg = new RegExp(\"((^|\\\\D)-\\\\d)|(-\" + escapeRegExp(prefix) + \")\");\n    var isNegative = reg.test(transformedValue);\n    // Is there a digit before the prefix? eg. 1$\n    var _k = RegExp(\"(\\\\d+)-?\" + escapeRegExp(prefix)).exec(value) || [], prefixWithValue = _k[0], preValue = _k[1];\n    var withoutPrefix = prefix\n        ? prefixWithValue\n            ? transformedValue.replace(prefixWithValue, '').concat(preValue)\n            : transformedValue.replace(prefix, '')\n        : transformedValue;\n    var withoutSeparators = removeSeparators(withoutPrefix, groupSeparator);\n    var withoutInvalidChars = removeInvalidChars(withoutSeparators, __spreadArray([\n        groupSeparator,\n        decimalSeparator\n    ], abbreviations));\n    var valueOnly = withoutInvalidChars;\n    if (!disableAbbreviations) {\n        // disallow letter without number\n        if (abbreviations.some(function (letter) { return letter === withoutInvalidChars.toLowerCase().replace(decimalSeparator, ''); })) {\n            return '';\n        }\n        var parsed = parseAbbrValue(withoutInvalidChars, decimalSeparator);\n        if (parsed) {\n            valueOnly = String(parsed);\n        }\n    }\n    var includeNegative = isNegative && allowNegativeValue ? '-' : '';\n    if (decimalSeparator && valueOnly.includes(decimalSeparator)) {\n        var _l = withoutInvalidChars.split(decimalSeparator), int = _l[0], decimals = _l[1];\n        var trimmedDecimals = decimalsLimit && decimals ? decimals.slice(0, decimalsLimit) : decimals;\n        var includeDecimals = allowDecimals ? \"\" + decimalSeparator + trimmedDecimals : '';\n        return \"\" + includeNegative + int + includeDecimals;\n    }\n    return \"\" + includeNegative + valueOnly;\n};\n\nvar fixedDecimalValue = function (value, decimalSeparator, fixedDecimalLength) {\n    if (fixedDecimalLength && value.length > 1) {\n        if (value.includes(decimalSeparator)) {\n            var _a = value.split(decimalSeparator), int = _a[0], decimals = _a[1];\n            if (decimals.length > fixedDecimalLength) {\n                return \"\" + int + decimalSeparator + decimals.slice(0, fixedDecimalLength);\n            }\n        }\n        var reg = value.length > fixedDecimalLength\n            ? new RegExp(\"(\\\\d+)(\\\\d{\" + fixedDecimalLength + \"})\")\n            : new RegExp(\"(\\\\d)(\\\\d+)\");\n        var match = value.match(reg);\n        if (match) {\n            var int = match[1], decimals = match[2];\n            return \"\" + int + decimalSeparator + decimals;\n        }\n    }\n    return value;\n};\n\nvar getSuffix = function (value, _a) {\n    var _b = _a.groupSeparator, groupSeparator = _b === void 0 ? ',' : _b, _c = _a.decimalSeparator, decimalSeparator = _c === void 0 ? '.' : _c;\n    var suffixReg = new RegExp(\"\\\\d([^\" + escapeRegExp(groupSeparator) + escapeRegExp(decimalSeparator) + \"0-9]+)\");\n    var suffixMatch = value.match(suffixReg);\n    return suffixMatch ? suffixMatch[1] : undefined;\n};\n\n/**\n * Format value with decimal separator, group separator and prefix\n */\nvar formatValue = function (options) {\n    var _value = options.value, decimalSeparator = options.decimalSeparator, intlConfig = options.intlConfig, decimalScale = options.decimalScale, _a = options.prefix, prefix = _a === void 0 ? '' : _a, _b = options.suffix, suffix = _b === void 0 ? '' : _b;\n    if (_value === '' || _value === undefined) {\n        return '';\n    }\n    if (_value === '-') {\n        return '-';\n    }\n    var isNegative = new RegExp(\"^\\\\d?-\" + (prefix ? escapeRegExp(prefix) + \"?\" : '') + \"\\\\d\").test(_value);\n    var value = decimalSeparator !== '.'\n        ? replaceDecimalSeparator(_value, decimalSeparator, isNegative)\n        : _value;\n    var defaultNumberFormatOptions = {\n        minimumFractionDigits: decimalScale || 0,\n        maximumFractionDigits: 20,\n    };\n    var numberFormatter = intlConfig\n        ? new Intl.NumberFormat(intlConfig.locale, intlConfig.currency\n            ? __assign(__assign({}, defaultNumberFormatOptions), { style: 'currency', currency: intlConfig.currency }) : defaultNumberFormatOptions)\n        : new Intl.NumberFormat(undefined, defaultNumberFormatOptions);\n    var parts = numberFormatter.formatToParts(Number(value));\n    var formatted = replaceParts(parts, options);\n    // Does intl formatting add a suffix?\n    var intlSuffix = getSuffix(formatted, __assign({}, options));\n    // Include decimal separator if user input ends with decimal separator\n    var includeDecimalSeparator = _value.slice(-1) === decimalSeparator ? decimalSeparator : '';\n    var _c = value.match(RegExp('\\\\d+\\\\.(\\\\d+)')) || [], decimals = _c[1];\n    // Keep original decimal padding if no decimalScale\n    if (decimalScale === undefined && decimals && decimalSeparator) {\n        if (formatted.includes(decimalSeparator)) {\n            formatted = formatted.replace(RegExp(\"(\\\\d+)(\" + escapeRegExp(decimalSeparator) + \")(\\\\d+)\", 'g'), \"$1$2\" + decimals);\n        }\n        else {\n            if (intlSuffix && !suffix) {\n                formatted = formatted.replace(intlSuffix, \"\" + decimalSeparator + decimals + intlSuffix);\n            }\n            else {\n                formatted = \"\" + formatted + decimalSeparator + decimals;\n            }\n        }\n    }\n    if (suffix && includeDecimalSeparator) {\n        return \"\" + formatted + includeDecimalSeparator + suffix;\n    }\n    if (intlSuffix && includeDecimalSeparator) {\n        return formatted.replace(intlSuffix, \"\" + includeDecimalSeparator + intlSuffix);\n    }\n    if (intlSuffix && suffix) {\n        return formatted.replace(intlSuffix, \"\" + includeDecimalSeparator + suffix);\n    }\n    return [formatted, includeDecimalSeparator, suffix].join('');\n};\n/**\n * Before converting to Number, decimal separator has to be .\n */\nvar replaceDecimalSeparator = function (value, decimalSeparator, isNegative) {\n    var newValue = value;\n    if (decimalSeparator && decimalSeparator !== '.') {\n        newValue = newValue.replace(RegExp(escapeRegExp(decimalSeparator), 'g'), '.');\n        if (isNegative && decimalSeparator === '-') {\n            newValue = \"-\" + newValue.slice(1);\n        }\n    }\n    return newValue;\n};\nvar replaceParts = function (parts, _a) {\n    var prefix = _a.prefix, groupSeparator = _a.groupSeparator, decimalSeparator = _a.decimalSeparator, decimalScale = _a.decimalScale, _b = _a.disableGroupSeparators, disableGroupSeparators = _b === void 0 ? false : _b;\n    return parts\n        .reduce(function (prev, _a, i) {\n        var type = _a.type, value = _a.value;\n        if (i === 0 && prefix) {\n            if (type === 'minusSign') {\n                return [value, prefix];\n            }\n            if (type === 'currency') {\n                return __spreadArray(__spreadArray([], prev), [prefix]);\n            }\n            return [prefix, value];\n        }\n        if (type === 'currency') {\n            return prefix ? prev : __spreadArray(__spreadArray([], prev), [value]);\n        }\n        if (type === 'group') {\n            return !disableGroupSeparators\n                ? __spreadArray(__spreadArray([], prev), [groupSeparator !== undefined ? groupSeparator : value]) : prev;\n        }\n        if (type === 'decimal') {\n            if (decimalScale !== undefined && decimalScale === 0) {\n                return prev;\n            }\n            return __spreadArray(__spreadArray([], prev), [decimalSeparator !== undefined ? decimalSeparator : value]);\n        }\n        if (type === 'fraction') {\n            return __spreadArray(__spreadArray([], prev), [decimalScale !== undefined ? value.slice(0, decimalScale) : value]);\n        }\n        return __spreadArray(__spreadArray([], prev), [value]);\n    }, [''])\n        .join('');\n};\n\nvar defaultConfig = {\n    currencySymbol: '',\n    groupSeparator: '',\n    decimalSeparator: '',\n    prefix: '',\n    suffix: '',\n};\n/**\n * Get locale config from input or default\n */\nvar getLocaleConfig = function (intlConfig) {\n    var _a = intlConfig || {}, locale = _a.locale, currency = _a.currency;\n    var numberFormatter = locale\n        ? new Intl.NumberFormat(locale, currency ? { currency: currency, style: 'currency' } : undefined)\n        : new Intl.NumberFormat();\n    return numberFormatter.formatToParts(1000.1).reduce(function (prev, curr, i) {\n        if (curr.type === 'currency') {\n            if (i === 0) {\n                return __assign(__assign({}, prev), { currencySymbol: curr.value, prefix: curr.value });\n            }\n            else {\n                return __assign(__assign({}, prev), { currencySymbol: curr.value, suffix: curr.value });\n            }\n        }\n        if (curr.type === 'group') {\n            return __assign(__assign({}, prev), { groupSeparator: curr.value });\n        }\n        if (curr.type === 'decimal') {\n            return __assign(__assign({}, prev), { decimalSeparator: curr.value });\n        }\n        return prev;\n    }, defaultConfig);\n};\n\nvar isNumber = function (input) { return RegExp(/\\d/, 'gi').test(input); };\n\nvar padTrimValue = function (value, decimalSeparator, decimalScale) {\n    if (decimalSeparator === void 0) { decimalSeparator = '.'; }\n    if (decimalScale === undefined || value === '' || value === undefined) {\n        return value;\n    }\n    if (!value.match(/\\d/g)) {\n        return '';\n    }\n    var _a = value.split(decimalSeparator), int = _a[0], decimals = _a[1];\n    if (decimalScale === 0) {\n        return int;\n    }\n    var newValue = decimals || '';\n    if (newValue.length < decimalScale) {\n        while (newValue.length < decimalScale) {\n            newValue += '0';\n        }\n    }\n    else {\n        newValue = newValue.slice(0, decimalScale);\n    }\n    return \"\" + int + decimalSeparator + newValue;\n};\n\n/**\n * Based on the last key stroke and the cursor position, update the value\n * and reposition the cursor to the right place\n */\nvar repositionCursor = function (_a) {\n    var selectionStart = _a.selectionStart, value = _a.value, lastKeyStroke = _a.lastKeyStroke, stateValue = _a.stateValue, groupSeparator = _a.groupSeparator;\n    var cursorPosition = selectionStart;\n    var modifiedValue = value;\n    if (stateValue && cursorPosition) {\n        var splitValue = value.split('');\n        // if cursor is to right of groupSeparator and backspace pressed, delete the character to the left of the separator and reposition the cursor\n        if (lastKeyStroke === 'Backspace' && stateValue[cursorPosition] === groupSeparator) {\n            splitValue.splice(cursorPosition - 1, 1);\n            cursorPosition -= 1;\n        }\n        // if cursor is to left of groupSeparator and delete pressed, delete the character to the right of the separator and reposition the cursor\n        if (lastKeyStroke === 'Delete' && stateValue[cursorPosition] === groupSeparator) {\n            splitValue.splice(cursorPosition, 1);\n            cursorPosition += 1;\n        }\n        modifiedValue = splitValue.join('');\n        return { modifiedValue: modifiedValue, cursorPosition: cursorPosition };\n    }\n    return { modifiedValue: modifiedValue, cursorPosition: selectionStart };\n};\n\nvar CurrencyInput = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_a, ref) {\n    var _b = _a.allowDecimals, allowDecimals = _b === void 0 ? true : _b, _c = _a.allowNegativeValue, allowNegativeValue = _c === void 0 ? true : _c, id = _a.id, name = _a.name, className = _a.className, customInput = _a.customInput, decimalsLimit = _a.decimalsLimit, defaultValue = _a.defaultValue, _d = _a.disabled, disabled = _d === void 0 ? false : _d, userMaxLength = _a.maxLength, userValue = _a.value, onValueChange = _a.onValueChange, fixedDecimalLength = _a.fixedDecimalLength, placeholder = _a.placeholder, decimalScale = _a.decimalScale, prefix = _a.prefix, suffix = _a.suffix, intlConfig = _a.intlConfig, step = _a.step, min = _a.min, max = _a.max, _e = _a.disableGroupSeparators, disableGroupSeparators = _e === void 0 ? false : _e, _f = _a.disableAbbreviations, disableAbbreviations = _f === void 0 ? false : _f, _decimalSeparator = _a.decimalSeparator, _groupSeparator = _a.groupSeparator, onChange = _a.onChange, onFocus = _a.onFocus, onBlur = _a.onBlur, onKeyDown = _a.onKeyDown, onKeyUp = _a.onKeyUp, transformRawValue = _a.transformRawValue, props = __rest(_a, [\"allowDecimals\", \"allowNegativeValue\", \"id\", \"name\", \"className\", \"customInput\", \"decimalsLimit\", \"defaultValue\", \"disabled\", \"maxLength\", \"value\", \"onValueChange\", \"fixedDecimalLength\", \"placeholder\", \"decimalScale\", \"prefix\", \"suffix\", \"intlConfig\", \"step\", \"min\", \"max\", \"disableGroupSeparators\", \"disableAbbreviations\", \"decimalSeparator\", \"groupSeparator\", \"onChange\", \"onFocus\", \"onBlur\", \"onKeyDown\", \"onKeyUp\", \"transformRawValue\"]);\n    if (_decimalSeparator && isNumber(_decimalSeparator)) {\n        throw new Error('decimalSeparator cannot be a number');\n    }\n    if (_groupSeparator && isNumber(_groupSeparator)) {\n        throw new Error('groupSeparator cannot be a number');\n    }\n    var localeConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () { return getLocaleConfig(intlConfig); }, [intlConfig]);\n    var decimalSeparator = _decimalSeparator || localeConfig.decimalSeparator || '';\n    var groupSeparator = _groupSeparator || localeConfig.groupSeparator || '';\n    if (decimalSeparator &&\n        groupSeparator &&\n        decimalSeparator === groupSeparator &&\n        disableGroupSeparators === false) {\n        throw new Error('decimalSeparator cannot be the same as groupSeparator');\n    }\n    var formatValueOptions = {\n        decimalSeparator: decimalSeparator,\n        groupSeparator: groupSeparator,\n        disableGroupSeparators: disableGroupSeparators,\n        intlConfig: intlConfig,\n        prefix: prefix || localeConfig.prefix,\n        suffix: suffix,\n    };\n    var cleanValueOptions = {\n        decimalSeparator: decimalSeparator,\n        groupSeparator: groupSeparator,\n        allowDecimals: allowDecimals,\n        decimalsLimit: decimalsLimit || fixedDecimalLength || 2,\n        allowNegativeValue: allowNegativeValue,\n        disableAbbreviations: disableAbbreviations,\n        prefix: prefix || localeConfig.prefix,\n        transformRawValue: transformRawValue,\n    };\n    var formattedStateValue = defaultValue !== undefined && defaultValue !== null\n        ? formatValue(__assign(__assign({}, formatValueOptions), { decimalScale: decimalScale, value: String(defaultValue) }))\n        : userValue !== undefined && userValue !== null\n            ? formatValue(__assign(__assign({}, formatValueOptions), { decimalScale: decimalScale, value: String(userValue) }))\n            : '';\n    var _g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(formattedStateValue), stateValue = _g[0], setStateValue = _g[1];\n    var _h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false), dirty = _h[0], setDirty = _h[1];\n    var _j = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), cursor = _j[0], setCursor = _j[1];\n    var _k = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), changeCount = _k[0], setChangeCount = _k[1];\n    var _l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), lastKeyStroke = _l[0], setLastKeyStroke = _l[1];\n    var inputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, function () { return inputRef.current; });\n    /**\n     * Process change in value\n     */\n    var processChange = function (value, selectionStart) {\n        setDirty(true);\n        var _a = repositionCursor({\n            selectionStart: selectionStart,\n            value: value,\n            lastKeyStroke: lastKeyStroke,\n            stateValue: stateValue,\n            groupSeparator: groupSeparator,\n        }), modifiedValue = _a.modifiedValue, cursorPosition = _a.cursorPosition;\n        var stringValue = cleanValue(__assign({ value: modifiedValue }, cleanValueOptions));\n        if (userMaxLength && stringValue.replace(/-/g, '').length > userMaxLength) {\n            return;\n        }\n        if (stringValue === '' || stringValue === '-' || stringValue === decimalSeparator) {\n            onValueChange && onValueChange(undefined, name, { float: null, formatted: '', value: '' });\n            setStateValue(stringValue);\n            // Always sets cursor after '-' or decimalSeparator input\n            setCursor(1);\n            return;\n        }\n        var stringValueWithoutSeparator = decimalSeparator\n            ? stringValue.replace(decimalSeparator, '.')\n            : stringValue;\n        var numberValue = parseFloat(stringValueWithoutSeparator);\n        var formattedValue = formatValue(__assign({ value: stringValue }, formatValueOptions));\n        if (cursorPosition !== undefined && cursorPosition !== null) {\n            // Prevent cursor jumping\n            var newCursor = cursorPosition + (formattedValue.length - value.length);\n            newCursor = newCursor <= 0 ? (prefix ? prefix.length : 0) : newCursor;\n            setCursor(newCursor);\n            setChangeCount(changeCount + 1);\n        }\n        setStateValue(formattedValue);\n        if (onValueChange) {\n            var values = {\n                float: numberValue,\n                formatted: formattedValue,\n                value: stringValue,\n            };\n            onValueChange(stringValue, name, values);\n        }\n    };\n    /**\n     * Handle change event\n     */\n    var handleOnChange = function (event) {\n        var _a = event.target, value = _a.value, selectionStart = _a.selectionStart;\n        processChange(value, selectionStart);\n        onChange && onChange(event);\n    };\n    /**\n     * Handle focus event\n     */\n    var handleOnFocus = function (event) {\n        onFocus && onFocus(event);\n        return stateValue ? stateValue.length : 0;\n    };\n    /**\n     * Handle blur event\n     *\n     * Format value by padding/trimming decimals if required by\n     */\n    var handleOnBlur = function (event) {\n        var value = event.target.value;\n        var valueOnly = cleanValue(__assign({ value: value }, cleanValueOptions));\n        if (valueOnly === '-' || valueOnly === decimalSeparator || !valueOnly) {\n            setStateValue('');\n            onBlur && onBlur(event);\n            return;\n        }\n        var fixedDecimals = fixedDecimalValue(valueOnly, decimalSeparator, fixedDecimalLength);\n        var newValue = padTrimValue(fixedDecimals, decimalSeparator, decimalScale !== undefined ? decimalScale : fixedDecimalLength);\n        var numberValue = parseFloat(newValue.replace(decimalSeparator, '.'));\n        var formattedValue = formatValue(__assign(__assign({}, formatValueOptions), { value: newValue }));\n        if (onValueChange) {\n            onValueChange(newValue, name, {\n                float: numberValue,\n                formatted: formattedValue,\n                value: newValue,\n            });\n        }\n        setStateValue(formattedValue);\n        onBlur && onBlur(event);\n    };\n    /**\n     * Handle key down event\n     *\n     * Increase or decrease value by step\n     */\n    var handleOnKeyDown = function (event) {\n        var key = event.key;\n        setLastKeyStroke(key);\n        if (step && (key === 'ArrowUp' || key === 'ArrowDown')) {\n            event.preventDefault();\n            setCursor(stateValue.length);\n            var currentValue = parseFloat(userValue !== undefined && userValue !== null\n                ? String(userValue).replace(decimalSeparator, '.')\n                : cleanValue(__assign({ value: stateValue }, cleanValueOptions))) || 0;\n            var newValue = key === 'ArrowUp' ? currentValue + step : currentValue - step;\n            if (min !== undefined && newValue < min) {\n                return;\n            }\n            if (max !== undefined && newValue > max) {\n                return;\n            }\n            var fixedLength = String(step).includes('.')\n                ? Number(String(step).split('.')[1].length)\n                : undefined;\n            processChange(String(fixedLength ? newValue.toFixed(fixedLength) : newValue).replace('.', decimalSeparator));\n        }\n        onKeyDown && onKeyDown(event);\n    };\n    /**\n     * Handle key up event\n     *\n     * Move cursor if there is a suffix to prevent user typing past suffix\n     */\n    var handleOnKeyUp = function (event) {\n        var key = event.key, selectionStart = event.currentTarget.selectionStart;\n        if (key !== 'ArrowUp' && key !== 'ArrowDown' && stateValue !== '-') {\n            var suffix_1 = getSuffix(stateValue, { groupSeparator: groupSeparator, decimalSeparator: decimalSeparator });\n            if (suffix_1 && selectionStart && selectionStart > stateValue.length - suffix_1.length) {\n                /* istanbul ignore else */\n                if (inputRef.current) {\n                    var newCursor = stateValue.length - suffix_1.length;\n                    inputRef.current.setSelectionRange(newCursor, newCursor);\n                }\n            }\n        }\n        onKeyUp && onKeyUp(event);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n        // prevent cursor jumping if editing value\n        if (dirty &&\n            stateValue !== '-' &&\n            inputRef.current &&\n            document.activeElement === inputRef.current) {\n            inputRef.current.setSelectionRange(cursor, cursor);\n        }\n    }, [stateValue, cursor, inputRef, dirty, changeCount]);\n    /**\n     * If user has only entered \"-\" or decimal separator,\n     * keep the char to allow them to enter next value\n     */\n    var getRenderValue = function () {\n        if (userValue !== undefined &&\n            userValue !== null &&\n            stateValue !== '-' &&\n            (!decimalSeparator || stateValue !== decimalSeparator)) {\n            return formatValue(__assign(__assign({}, formatValueOptions), { decimalScale: dirty ? undefined : decimalScale, value: String(userValue) }));\n        }\n        return stateValue;\n    };\n    var inputProps = __assign({ type: 'text', inputMode: 'decimal', id: id,\n        name: name,\n        className: className, onChange: handleOnChange, onBlur: handleOnBlur, onFocus: handleOnFocus, onKeyDown: handleOnKeyDown, onKeyUp: handleOnKeyUp, placeholder: placeholder,\n        disabled: disabled, value: getRenderValue(), ref: inputRef }, props);\n    if (customInput) {\n        var CustomInput = customInput;\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CustomInput, __assign({}, inputProps));\n    }\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", __assign({}, inputProps));\n});\nCurrencyInput.displayName = 'CurrencyInput';\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CurrencyInput);\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY3VycmVuY3ktaW5wdXQtZmllbGQvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFxRzs7QUFFckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlrQkFBeWtCLG1CQUFtQjtBQUM1bEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsb0ZBQW9GO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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YUFBYSxFQUFDO0FBQ047QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWR1c2EtbmV4dC8uL25vZGVfbW9kdWxlcy9yZWFjdC1jdXJyZW5jeS1pbnB1dC1maWVsZC9kaXN0L2luZGV4LmVzbS5qcz9iZGVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VNZW1vLCB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgZnJvbSk7XHJcbn1cblxuLyoqXG4gKiBFc2NhcGUgcmVnZXggY2hhclxuICpcbiAqIFNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTc4ODU4NTUvdXNlLWR5bmFtaWMtdmFyaWFibGUtc3RyaW5nLWFzLXJlZ2V4LXBhdHRlcm4taW4tamF2YXNjcmlwdFxuICovXG52YXIgZXNjYXBlUmVnRXhwID0gZnVuY3Rpb24gKHN0cmluZ1RvR29JbnRvVGhlUmVnZXgpIHtcbiAgICByZXR1cm4gc3RyaW5nVG9Hb0ludG9UaGVSZWdleC5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbn07XG5cbnZhciBhYmJyTWFwID0geyBrOiAxMDAwLCBtOiAxMDAwMDAwLCBiOiAxMDAwMDAwMDAwIH07XG4vKipcbiAqIFBhcnNlIGEgdmFsdWUgd2l0aCBhYmJyZXZpYXRpb24gZS5nIDFrID0gMTAwMFxuICovXG52YXIgcGFyc2VBYmJyVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGRlY2ltYWxTZXBhcmF0b3IpIHtcbiAgICBpZiAoZGVjaW1hbFNlcGFyYXRvciA9PT0gdm9pZCAwKSB7IGRlY2ltYWxTZXBhcmF0b3IgPSAnLic7IH1cbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChcIihcXFxcZCsoXCIgKyBlc2NhcGVSZWdFeHAoZGVjaW1hbFNlcGFyYXRvcikgKyBcIlxcXFxkKik/KShba21iXSkkXCIsICdpJyk7XG4gICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2gocmVnKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGRpZ2l0cyA9IG1hdGNoWzFdLCBhYmJyID0gbWF0Y2hbM107XG4gICAgICAgIHZhciBtdWx0aXBsaWVyID0gYWJick1hcFthYmJyLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICByZXR1cm4gTnVtYmVyKGRpZ2l0cy5yZXBsYWNlKGRlY2ltYWxTZXBhcmF0b3IsICcuJykpICogbXVsdGlwbGllcjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGdyb3VwIHNlcGFyYXRvciBmcm9tIHZhbHVlIGVnLiAxLDAwMCA+IDEwMDBcbiAqL1xudmFyIHJlbW92ZVNlcGFyYXRvcnMgPSBmdW5jdGlvbiAodmFsdWUsIHNlcGFyYXRvcikge1xuICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCkgeyBzZXBhcmF0b3IgPSAnLCc7IH1cbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAoc2VwYXJhdG9yKSwgJ2cnKTtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZShyZWcsICcnKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGludmFsaWQgY2hhcmFjdGVyc1xuICovXG52YXIgcmVtb3ZlSW52YWxpZENoYXJzID0gZnVuY3Rpb24gKHZhbHVlLCB2YWxpZENoYXJzKSB7XG4gICAgdmFyIGNoYXJzID0gZXNjYXBlUmVnRXhwKHZhbGlkQ2hhcnMuam9pbignJykpO1xuICAgIHZhciByZWcgPSBuZXcgUmVnRXhwKFwiW15cXFxcZFwiICsgY2hhcnMgKyBcIl1cIiwgJ2dpJyk7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmVnLCAnJyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBwcmVmaXgsIHNlcGFyYXRvcnMgYW5kIGV4dHJhIGRlY2ltYWxzIGZyb20gdmFsdWVcbiAqL1xudmFyIGNsZWFuVmFsdWUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZSwgX2IgPSBfYS5ncm91cFNlcGFyYXRvciwgZ3JvdXBTZXBhcmF0b3IgPSBfYiA9PT0gdm9pZCAwID8gJywnIDogX2IsIF9jID0gX2EuZGVjaW1hbFNlcGFyYXRvciwgZGVjaW1hbFNlcGFyYXRvciA9IF9jID09PSB2b2lkIDAgPyAnLicgOiBfYywgX2QgPSBfYS5hbGxvd0RlY2ltYWxzLCBhbGxvd0RlY2ltYWxzID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZCwgX2UgPSBfYS5kZWNpbWFsc0xpbWl0LCBkZWNpbWFsc0xpbWl0ID0gX2UgPT09IHZvaWQgMCA/IDIgOiBfZSwgX2YgPSBfYS5hbGxvd05lZ2F0aXZlVmFsdWUsIGFsbG93TmVnYXRpdmVWYWx1ZSA9IF9mID09PSB2b2lkIDAgPyB0cnVlIDogX2YsIF9nID0gX2EuZGlzYWJsZUFiYnJldmlhdGlvbnMsIGRpc2FibGVBYmJyZXZpYXRpb25zID0gX2cgPT09IHZvaWQgMCA/IGZhbHNlIDogX2csIF9oID0gX2EucHJlZml4LCBwcmVmaXggPSBfaCA9PT0gdm9pZCAwID8gJycgOiBfaCwgX2ogPSBfYS50cmFuc2Zvcm1SYXdWYWx1ZSwgdHJhbnNmb3JtUmF3VmFsdWUgPSBfaiA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHJhd1ZhbHVlKSB7IHJldHVybiByYXdWYWx1ZTsgfSA6IF9qO1xuICAgIHZhciB0cmFuc2Zvcm1lZFZhbHVlID0gdHJhbnNmb3JtUmF3VmFsdWUodmFsdWUpO1xuICAgIGlmICh0cmFuc2Zvcm1lZFZhbHVlID09PSAnLScpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkVmFsdWU7XG4gICAgfVxuICAgIHZhciBhYmJyZXZpYXRpb25zID0gZGlzYWJsZUFiYnJldmlhdGlvbnMgPyBbXSA6IFsnaycsICdtJywgJ2InXTtcbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChcIigoXnxcXFxcRCktXFxcXGQpfCgtXCIgKyBlc2NhcGVSZWdFeHAocHJlZml4KSArIFwiKVwiKTtcbiAgICB2YXIgaXNOZWdhdGl2ZSA9IHJlZy50ZXN0KHRyYW5zZm9ybWVkVmFsdWUpO1xuICAgIC8vIElzIHRoZXJlIGEgZGlnaXQgYmVmb3JlIHRoZSBwcmVmaXg/IGVnLiAxJFxuICAgIHZhciBfayA9IFJlZ0V4cChcIihcXFxcZCspLT9cIiArIGVzY2FwZVJlZ0V4cChwcmVmaXgpKS5leGVjKHZhbHVlKSB8fCBbXSwgcHJlZml4V2l0aFZhbHVlID0gX2tbMF0sIHByZVZhbHVlID0gX2tbMV07XG4gICAgdmFyIHdpdGhvdXRQcmVmaXggPSBwcmVmaXhcbiAgICAgICAgPyBwcmVmaXhXaXRoVmFsdWVcbiAgICAgICAgICAgID8gdHJhbnNmb3JtZWRWYWx1ZS5yZXBsYWNlKHByZWZpeFdpdGhWYWx1ZSwgJycpLmNvbmNhdChwcmVWYWx1ZSlcbiAgICAgICAgICAgIDogdHJhbnNmb3JtZWRWYWx1ZS5yZXBsYWNlKHByZWZpeCwgJycpXG4gICAgICAgIDogdHJhbnNmb3JtZWRWYWx1ZTtcbiAgICB2YXIgd2l0aG91dFNlcGFyYXRvcnMgPSByZW1vdmVTZXBhcmF0b3JzKHdpdGhvdXRQcmVmaXgsIGdyb3VwU2VwYXJhdG9yKTtcbiAgICB2YXIgd2l0aG91dEludmFsaWRDaGFycyA9IHJlbW92ZUludmFsaWRDaGFycyh3aXRob3V0U2VwYXJhdG9ycywgX19zcHJlYWRBcnJheShbXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yLFxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yXG4gICAgXSwgYWJicmV2aWF0aW9ucykpO1xuICAgIHZhciB2YWx1ZU9ubHkgPSB3aXRob3V0SW52YWxpZENoYXJzO1xuICAgIGlmICghZGlzYWJsZUFiYnJldmlhdGlvbnMpIHtcbiAgICAgICAgLy8gZGlzYWxsb3cgbGV0dGVyIHdpdGhvdXQgbnVtYmVyXG4gICAgICAgIGlmIChhYmJyZXZpYXRpb25zLnNvbWUoZnVuY3Rpb24gKGxldHRlcikgeyByZXR1cm4gbGV0dGVyID09PSB3aXRob3V0SW52YWxpZENoYXJzLnRvTG93ZXJDYXNlKCkucmVwbGFjZShkZWNpbWFsU2VwYXJhdG9yLCAnJyk7IH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlQWJiclZhbHVlKHdpdGhvdXRJbnZhbGlkQ2hhcnMsIGRlY2ltYWxTZXBhcmF0b3IpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICB2YWx1ZU9ubHkgPSBTdHJpbmcocGFyc2VkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW5jbHVkZU5lZ2F0aXZlID0gaXNOZWdhdGl2ZSAmJiBhbGxvd05lZ2F0aXZlVmFsdWUgPyAnLScgOiAnJztcbiAgICBpZiAoZGVjaW1hbFNlcGFyYXRvciAmJiB2YWx1ZU9ubHkuaW5jbHVkZXMoZGVjaW1hbFNlcGFyYXRvcikpIHtcbiAgICAgICAgdmFyIF9sID0gd2l0aG91dEludmFsaWRDaGFycy5zcGxpdChkZWNpbWFsU2VwYXJhdG9yKSwgaW50ID0gX2xbMF0sIGRlY2ltYWxzID0gX2xbMV07XG4gICAgICAgIHZhciB0cmltbWVkRGVjaW1hbHMgPSBkZWNpbWFsc0xpbWl0ICYmIGRlY2ltYWxzID8gZGVjaW1hbHMuc2xpY2UoMCwgZGVjaW1hbHNMaW1pdCkgOiBkZWNpbWFscztcbiAgICAgICAgdmFyIGluY2x1ZGVEZWNpbWFscyA9IGFsbG93RGVjaW1hbHMgPyBcIlwiICsgZGVjaW1hbFNlcGFyYXRvciArIHRyaW1tZWREZWNpbWFscyA6ICcnO1xuICAgICAgICByZXR1cm4gXCJcIiArIGluY2x1ZGVOZWdhdGl2ZSArIGludCArIGluY2x1ZGVEZWNpbWFscztcbiAgICB9XG4gICAgcmV0dXJuIFwiXCIgKyBpbmNsdWRlTmVnYXRpdmUgKyB2YWx1ZU9ubHk7XG59O1xuXG52YXIgZml4ZWREZWNpbWFsVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGRlY2ltYWxTZXBhcmF0b3IsIGZpeGVkRGVjaW1hbExlbmd0aCkge1xuICAgIGlmIChmaXhlZERlY2ltYWxMZW5ndGggJiYgdmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoZGVjaW1hbFNlcGFyYXRvcikpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHZhbHVlLnNwbGl0KGRlY2ltYWxTZXBhcmF0b3IpLCBpbnQgPSBfYVswXSwgZGVjaW1hbHMgPSBfYVsxXTtcbiAgICAgICAgICAgIGlmIChkZWNpbWFscy5sZW5ndGggPiBmaXhlZERlY2ltYWxMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIiArIGludCArIGRlY2ltYWxTZXBhcmF0b3IgKyBkZWNpbWFscy5zbGljZSgwLCBmaXhlZERlY2ltYWxMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZWcgPSB2YWx1ZS5sZW5ndGggPiBmaXhlZERlY2ltYWxMZW5ndGhcbiAgICAgICAgICAgID8gbmV3IFJlZ0V4cChcIihcXFxcZCspKFxcXFxke1wiICsgZml4ZWREZWNpbWFsTGVuZ3RoICsgXCJ9KVwiKVxuICAgICAgICAgICAgOiBuZXcgUmVnRXhwKFwiKFxcXFxkKShcXFxcZCspXCIpO1xuICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaChyZWcpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBpbnQgPSBtYXRjaFsxXSwgZGVjaW1hbHMgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgaW50ICsgZGVjaW1hbFNlcGFyYXRvciArIGRlY2ltYWxzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBnZXRTdWZmaXggPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgdmFyIF9iID0gX2EuZ3JvdXBTZXBhcmF0b3IsIGdyb3VwU2VwYXJhdG9yID0gX2IgPT09IHZvaWQgMCA/ICcsJyA6IF9iLCBfYyA9IF9hLmRlY2ltYWxTZXBhcmF0b3IsIGRlY2ltYWxTZXBhcmF0b3IgPSBfYyA9PT0gdm9pZCAwID8gJy4nIDogX2M7XG4gICAgdmFyIHN1ZmZpeFJlZyA9IG5ldyBSZWdFeHAoXCJcXFxcZChbXlwiICsgZXNjYXBlUmVnRXhwKGdyb3VwU2VwYXJhdG9yKSArIGVzY2FwZVJlZ0V4cChkZWNpbWFsU2VwYXJhdG9yKSArIFwiMC05XSspXCIpO1xuICAgIHZhciBzdWZmaXhNYXRjaCA9IHZhbHVlLm1hdGNoKHN1ZmZpeFJlZyk7XG4gICAgcmV0dXJuIHN1ZmZpeE1hdGNoID8gc3VmZml4TWF0Y2hbMV0gOiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEZvcm1hdCB2YWx1ZSB3aXRoIGRlY2ltYWwgc2VwYXJhdG9yLCBncm91cCBzZXBhcmF0b3IgYW5kIHByZWZpeFxuICovXG52YXIgZm9ybWF0VmFsdWUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBfdmFsdWUgPSBvcHRpb25zLnZhbHVlLCBkZWNpbWFsU2VwYXJhdG9yID0gb3B0aW9ucy5kZWNpbWFsU2VwYXJhdG9yLCBpbnRsQ29uZmlnID0gb3B0aW9ucy5pbnRsQ29uZmlnLCBkZWNpbWFsU2NhbGUgPSBvcHRpb25zLmRlY2ltYWxTY2FsZSwgX2EgPSBvcHRpb25zLnByZWZpeCwgcHJlZml4ID0gX2EgPT09IHZvaWQgMCA/ICcnIDogX2EsIF9iID0gb3B0aW9ucy5zdWZmaXgsIHN1ZmZpeCA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xuICAgIGlmIChfdmFsdWUgPT09ICcnIHx8IF92YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKF92YWx1ZSA9PT0gJy0nKSB7XG4gICAgICAgIHJldHVybiAnLSc7XG4gICAgfVxuICAgIHZhciBpc05lZ2F0aXZlID0gbmV3IFJlZ0V4cChcIl5cXFxcZD8tXCIgKyAocHJlZml4ID8gZXNjYXBlUmVnRXhwKHByZWZpeCkgKyBcIj9cIiA6ICcnKSArIFwiXFxcXGRcIikudGVzdChfdmFsdWUpO1xuICAgIHZhciB2YWx1ZSA9IGRlY2ltYWxTZXBhcmF0b3IgIT09ICcuJ1xuICAgICAgICA/IHJlcGxhY2VEZWNpbWFsU2VwYXJhdG9yKF92YWx1ZSwgZGVjaW1hbFNlcGFyYXRvciwgaXNOZWdhdGl2ZSlcbiAgICAgICAgOiBfdmFsdWU7XG4gICAgdmFyIGRlZmF1bHROdW1iZXJGb3JtYXRPcHRpb25zID0ge1xuICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IGRlY2ltYWxTY2FsZSB8fCAwLFxuICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDIwLFxuICAgIH07XG4gICAgdmFyIG51bWJlckZvcm1hdHRlciA9IGludGxDb25maWdcbiAgICAgICAgPyBuZXcgSW50bC5OdW1iZXJGb3JtYXQoaW50bENvbmZpZy5sb2NhbGUsIGludGxDb25maWcuY3VycmVuY3lcbiAgICAgICAgICAgID8gX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHROdW1iZXJGb3JtYXRPcHRpb25zKSwgeyBzdHlsZTogJ2N1cnJlbmN5JywgY3VycmVuY3k6IGludGxDb25maWcuY3VycmVuY3kgfSkgOiBkZWZhdWx0TnVtYmVyRm9ybWF0T3B0aW9ucylcbiAgICAgICAgOiBuZXcgSW50bC5OdW1iZXJGb3JtYXQodW5kZWZpbmVkLCBkZWZhdWx0TnVtYmVyRm9ybWF0T3B0aW9ucyk7XG4gICAgdmFyIHBhcnRzID0gbnVtYmVyRm9ybWF0dGVyLmZvcm1hdFRvUGFydHMoTnVtYmVyKHZhbHVlKSk7XG4gICAgdmFyIGZvcm1hdHRlZCA9IHJlcGxhY2VQYXJ0cyhwYXJ0cywgb3B0aW9ucyk7XG4gICAgLy8gRG9lcyBpbnRsIGZvcm1hdHRpbmcgYWRkIGEgc3VmZml4P1xuICAgIHZhciBpbnRsU3VmZml4ID0gZ2V0U3VmZml4KGZvcm1hdHRlZCwgX19hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgICAvLyBJbmNsdWRlIGRlY2ltYWwgc2VwYXJhdG9yIGlmIHVzZXIgaW5wdXQgZW5kcyB3aXRoIGRlY2ltYWwgc2VwYXJhdG9yXG4gICAgdmFyIGluY2x1ZGVEZWNpbWFsU2VwYXJhdG9yID0gX3ZhbHVlLnNsaWNlKC0xKSA9PT0gZGVjaW1hbFNlcGFyYXRvciA/IGRlY2ltYWxTZXBhcmF0b3IgOiAnJztcbiAgICB2YXIgX2MgPSB2YWx1ZS5tYXRjaChSZWdFeHAoJ1xcXFxkK1xcXFwuKFxcXFxkKyknKSkgfHwgW10sIGRlY2ltYWxzID0gX2NbMV07XG4gICAgLy8gS2VlcCBvcmlnaW5hbCBkZWNpbWFsIHBhZGRpbmcgaWYgbm8gZGVjaW1hbFNjYWxlXG4gICAgaWYgKGRlY2ltYWxTY2FsZSA9PT0gdW5kZWZpbmVkICYmIGRlY2ltYWxzICYmIGRlY2ltYWxTZXBhcmF0b3IpIHtcbiAgICAgICAgaWYgKGZvcm1hdHRlZC5pbmNsdWRlcyhkZWNpbWFsU2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgZm9ybWF0dGVkID0gZm9ybWF0dGVkLnJlcGxhY2UoUmVnRXhwKFwiKFxcXFxkKykoXCIgKyBlc2NhcGVSZWdFeHAoZGVjaW1hbFNlcGFyYXRvcikgKyBcIikoXFxcXGQrKVwiLCAnZycpLCBcIiQxJDJcIiArIGRlY2ltYWxzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbnRsU3VmZml4ICYmICFzdWZmaXgpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQgPSBmb3JtYXR0ZWQucmVwbGFjZShpbnRsU3VmZml4LCBcIlwiICsgZGVjaW1hbFNlcGFyYXRvciArIGRlY2ltYWxzICsgaW50bFN1ZmZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQgPSBcIlwiICsgZm9ybWF0dGVkICsgZGVjaW1hbFNlcGFyYXRvciArIGRlY2ltYWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdWZmaXggJiYgaW5jbHVkZURlY2ltYWxTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBmb3JtYXR0ZWQgKyBpbmNsdWRlRGVjaW1hbFNlcGFyYXRvciArIHN1ZmZpeDtcbiAgICB9XG4gICAgaWYgKGludGxTdWZmaXggJiYgaW5jbHVkZURlY2ltYWxTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZC5yZXBsYWNlKGludGxTdWZmaXgsIFwiXCIgKyBpbmNsdWRlRGVjaW1hbFNlcGFyYXRvciArIGludGxTdWZmaXgpO1xuICAgIH1cbiAgICBpZiAoaW50bFN1ZmZpeCAmJiBzdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZC5yZXBsYWNlKGludGxTdWZmaXgsIFwiXCIgKyBpbmNsdWRlRGVjaW1hbFNlcGFyYXRvciArIHN1ZmZpeCk7XG4gICAgfVxuICAgIHJldHVybiBbZm9ybWF0dGVkLCBpbmNsdWRlRGVjaW1hbFNlcGFyYXRvciwgc3VmZml4XS5qb2luKCcnKTtcbn07XG4vKipcbiAqIEJlZm9yZSBjb252ZXJ0aW5nIHRvIE51bWJlciwgZGVjaW1hbCBzZXBhcmF0b3IgaGFzIHRvIGJlIC5cbiAqL1xudmFyIHJlcGxhY2VEZWNpbWFsU2VwYXJhdG9yID0gZnVuY3Rpb24gKHZhbHVlLCBkZWNpbWFsU2VwYXJhdG9yLCBpc05lZ2F0aXZlKSB7XG4gICAgdmFyIG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgaWYgKGRlY2ltYWxTZXBhcmF0b3IgJiYgZGVjaW1hbFNlcGFyYXRvciAhPT0gJy4nKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUucmVwbGFjZShSZWdFeHAoZXNjYXBlUmVnRXhwKGRlY2ltYWxTZXBhcmF0b3IpLCAnZycpLCAnLicpO1xuICAgICAgICBpZiAoaXNOZWdhdGl2ZSAmJiBkZWNpbWFsU2VwYXJhdG9yID09PSAnLScpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gXCItXCIgKyBuZXdWYWx1ZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWU7XG59O1xudmFyIHJlcGxhY2VQYXJ0cyA9IGZ1bmN0aW9uIChwYXJ0cywgX2EpIHtcbiAgICB2YXIgcHJlZml4ID0gX2EucHJlZml4LCBncm91cFNlcGFyYXRvciA9IF9hLmdyb3VwU2VwYXJhdG9yLCBkZWNpbWFsU2VwYXJhdG9yID0gX2EuZGVjaW1hbFNlcGFyYXRvciwgZGVjaW1hbFNjYWxlID0gX2EuZGVjaW1hbFNjYWxlLCBfYiA9IF9hLmRpc2FibGVHcm91cFNlcGFyYXRvcnMsIGRpc2FibGVHcm91cFNlcGFyYXRvcnMgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYjtcbiAgICByZXR1cm4gcGFydHNcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAocHJldiwgX2EsIGkpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICBpZiAoaSA9PT0gMCAmJiBwcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbWludXNTaWduJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdmFsdWUsIHByZWZpeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2N1cnJlbmN5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHByZXYpLCBbcHJlZml4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3ByZWZpeCwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY3VycmVuY3knKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ID8gcHJldiA6IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcHJldiksIFt2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICByZXR1cm4gIWRpc2FibGVHcm91cFNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgICA/IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcHJldiksIFtncm91cFNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gZ3JvdXBTZXBhcmF0b3IgOiB2YWx1ZV0pIDogcHJldjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RlY2ltYWwnKSB7XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFNjYWxlICE9PSB1bmRlZmluZWQgJiYgZGVjaW1hbFNjYWxlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBwcmV2KSwgW2RlY2ltYWxTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IGRlY2ltYWxTZXBhcmF0b3IgOiB2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZnJhY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBwcmV2KSwgW2RlY2ltYWxTY2FsZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUuc2xpY2UoMCwgZGVjaW1hbFNjYWxlKSA6IHZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcHJldiksIFt2YWx1ZV0pO1xuICAgIH0sIFsnJ10pXG4gICAgICAgIC5qb2luKCcnKTtcbn07XG5cbnZhciBkZWZhdWx0Q29uZmlnID0ge1xuICAgIGN1cnJlbmN5U3ltYm9sOiAnJyxcbiAgICBncm91cFNlcGFyYXRvcjogJycsXG4gICAgZGVjaW1hbFNlcGFyYXRvcjogJycsXG4gICAgcHJlZml4OiAnJyxcbiAgICBzdWZmaXg6ICcnLFxufTtcbi8qKlxuICogR2V0IGxvY2FsZSBjb25maWcgZnJvbSBpbnB1dCBvciBkZWZhdWx0XG4gKi9cbnZhciBnZXRMb2NhbGVDb25maWcgPSBmdW5jdGlvbiAoaW50bENvbmZpZykge1xuICAgIHZhciBfYSA9IGludGxDb25maWcgfHwge30sIGxvY2FsZSA9IF9hLmxvY2FsZSwgY3VycmVuY3kgPSBfYS5jdXJyZW5jeTtcbiAgICB2YXIgbnVtYmVyRm9ybWF0dGVyID0gbG9jYWxlXG4gICAgICAgID8gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgY3VycmVuY3kgPyB7IGN1cnJlbmN5OiBjdXJyZW5jeSwgc3R5bGU6ICdjdXJyZW5jeScgfSA6IHVuZGVmaW5lZClcbiAgICAgICAgOiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoKTtcbiAgICByZXR1cm4gbnVtYmVyRm9ybWF0dGVyLmZvcm1hdFRvUGFydHMoMTAwMC4xKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIsIGkpIHtcbiAgICAgICAgaWYgKGN1cnIudHlwZSA9PT0gJ2N1cnJlbmN5Jykge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXYpLCB7IGN1cnJlbmN5U3ltYm9sOiBjdXJyLnZhbHVlLCBwcmVmaXg6IGN1cnIudmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXYpLCB7IGN1cnJlbmN5U3ltYm9sOiBjdXJyLnZhbHVlLCBzdWZmaXg6IGN1cnIudmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnIudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2KSwgeyBncm91cFNlcGFyYXRvcjogY3Vyci52YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3Vyci50eXBlID09PSAnZGVjaW1hbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldiksIHsgZGVjaW1hbFNlcGFyYXRvcjogY3Vyci52YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldjtcbiAgICB9LCBkZWZhdWx0Q29uZmlnKTtcbn07XG5cbnZhciBpc051bWJlciA9IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gUmVnRXhwKC9cXGQvLCAnZ2knKS50ZXN0KGlucHV0KTsgfTtcblxudmFyIHBhZFRyaW1WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVjaW1hbFNlcGFyYXRvciwgZGVjaW1hbFNjYWxlKSB7XG4gICAgaWYgKGRlY2ltYWxTZXBhcmF0b3IgPT09IHZvaWQgMCkgeyBkZWNpbWFsU2VwYXJhdG9yID0gJy4nOyB9XG4gICAgaWYgKGRlY2ltYWxTY2FsZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZS5tYXRjaCgvXFxkL2cpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIF9hID0gdmFsdWUuc3BsaXQoZGVjaW1hbFNlcGFyYXRvciksIGludCA9IF9hWzBdLCBkZWNpbWFscyA9IF9hWzFdO1xuICAgIGlmIChkZWNpbWFsU2NhbGUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGludDtcbiAgICB9XG4gICAgdmFyIG5ld1ZhbHVlID0gZGVjaW1hbHMgfHwgJyc7XG4gICAgaWYgKG5ld1ZhbHVlLmxlbmd0aCA8IGRlY2ltYWxTY2FsZSkge1xuICAgICAgICB3aGlsZSAobmV3VmFsdWUubGVuZ3RoIDwgZGVjaW1hbFNjYWxlKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSArPSAnMCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUuc2xpY2UoMCwgZGVjaW1hbFNjYWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCIgKyBpbnQgKyBkZWNpbWFsU2VwYXJhdG9yICsgbmV3VmFsdWU7XG59O1xuXG4vKipcbiAqIEJhc2VkIG9uIHRoZSBsYXN0IGtleSBzdHJva2UgYW5kIHRoZSBjdXJzb3IgcG9zaXRpb24sIHVwZGF0ZSB0aGUgdmFsdWVcbiAqIGFuZCByZXBvc2l0aW9uIHRoZSBjdXJzb3IgdG8gdGhlIHJpZ2h0IHBsYWNlXG4gKi9cbnZhciByZXBvc2l0aW9uQ3Vyc29yID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gX2Euc2VsZWN0aW9uU3RhcnQsIHZhbHVlID0gX2EudmFsdWUsIGxhc3RLZXlTdHJva2UgPSBfYS5sYXN0S2V5U3Ryb2tlLCBzdGF0ZVZhbHVlID0gX2Euc3RhdGVWYWx1ZSwgZ3JvdXBTZXBhcmF0b3IgPSBfYS5ncm91cFNlcGFyYXRvcjtcbiAgICB2YXIgY3Vyc29yUG9zaXRpb24gPSBzZWxlY3Rpb25TdGFydDtcbiAgICB2YXIgbW9kaWZpZWRWYWx1ZSA9IHZhbHVlO1xuICAgIGlmIChzdGF0ZVZhbHVlICYmIGN1cnNvclBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBzcGxpdFZhbHVlID0gdmFsdWUuc3BsaXQoJycpO1xuICAgICAgICAvLyBpZiBjdXJzb3IgaXMgdG8gcmlnaHQgb2YgZ3JvdXBTZXBhcmF0b3IgYW5kIGJhY2tzcGFjZSBwcmVzc2VkLCBkZWxldGUgdGhlIGNoYXJhY3RlciB0byB0aGUgbGVmdCBvZiB0aGUgc2VwYXJhdG9yIGFuZCByZXBvc2l0aW9uIHRoZSBjdXJzb3JcbiAgICAgICAgaWYgKGxhc3RLZXlTdHJva2UgPT09ICdCYWNrc3BhY2UnICYmIHN0YXRlVmFsdWVbY3Vyc29yUG9zaXRpb25dID09PSBncm91cFNlcGFyYXRvcikge1xuICAgICAgICAgICAgc3BsaXRWYWx1ZS5zcGxpY2UoY3Vyc29yUG9zaXRpb24gLSAxLCAxKTtcbiAgICAgICAgICAgIGN1cnNvclBvc2l0aW9uIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgY3Vyc29yIGlzIHRvIGxlZnQgb2YgZ3JvdXBTZXBhcmF0b3IgYW5kIGRlbGV0ZSBwcmVzc2VkLCBkZWxldGUgdGhlIGNoYXJhY3RlciB0byB0aGUgcmlnaHQgb2YgdGhlIHNlcGFyYXRvciBhbmQgcmVwb3NpdGlvbiB0aGUgY3Vyc29yXG4gICAgICAgIGlmIChsYXN0S2V5U3Ryb2tlID09PSAnRGVsZXRlJyAmJiBzdGF0ZVZhbHVlW2N1cnNvclBvc2l0aW9uXSA9PT0gZ3JvdXBTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHNwbGl0VmFsdWUuc3BsaWNlKGN1cnNvclBvc2l0aW9uLCAxKTtcbiAgICAgICAgICAgIGN1cnNvclBvc2l0aW9uICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbW9kaWZpZWRWYWx1ZSA9IHNwbGl0VmFsdWUuam9pbignJyk7XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkVmFsdWU6IG1vZGlmaWVkVmFsdWUsIGN1cnNvclBvc2l0aW9uOiBjdXJzb3JQb3NpdGlvbiB9O1xuICAgIH1cbiAgICByZXR1cm4geyBtb2RpZmllZFZhbHVlOiBtb2RpZmllZFZhbHVlLCBjdXJzb3JQb3NpdGlvbjogc2VsZWN0aW9uU3RhcnQgfTtcbn07XG5cbnZhciBDdXJyZW5jeUlucHV0ID0gZm9yd2FyZFJlZihmdW5jdGlvbiAoX2EsIHJlZikge1xuICAgIHZhciBfYiA9IF9hLmFsbG93RGVjaW1hbHMsIGFsbG93RGVjaW1hbHMgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBfYyA9IF9hLmFsbG93TmVnYXRpdmVWYWx1ZSwgYWxsb3dOZWdhdGl2ZVZhbHVlID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgaWQgPSBfYS5pZCwgbmFtZSA9IF9hLm5hbWUsIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgY3VzdG9tSW5wdXQgPSBfYS5jdXN0b21JbnB1dCwgZGVjaW1hbHNMaW1pdCA9IF9hLmRlY2ltYWxzTGltaXQsIGRlZmF1bHRWYWx1ZSA9IF9hLmRlZmF1bHRWYWx1ZSwgX2QgPSBfYS5kaXNhYmxlZCwgZGlzYWJsZWQgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgdXNlck1heExlbmd0aCA9IF9hLm1heExlbmd0aCwgdXNlclZhbHVlID0gX2EudmFsdWUsIG9uVmFsdWVDaGFuZ2UgPSBfYS5vblZhbHVlQ2hhbmdlLCBmaXhlZERlY2ltYWxMZW5ndGggPSBfYS5maXhlZERlY2ltYWxMZW5ndGgsIHBsYWNlaG9sZGVyID0gX2EucGxhY2Vob2xkZXIsIGRlY2ltYWxTY2FsZSA9IF9hLmRlY2ltYWxTY2FsZSwgcHJlZml4ID0gX2EucHJlZml4LCBzdWZmaXggPSBfYS5zdWZmaXgsIGludGxDb25maWcgPSBfYS5pbnRsQ29uZmlnLCBzdGVwID0gX2Euc3RlcCwgbWluID0gX2EubWluLCBtYXggPSBfYS5tYXgsIF9lID0gX2EuZGlzYWJsZUdyb3VwU2VwYXJhdG9ycywgZGlzYWJsZUdyb3VwU2VwYXJhdG9ycyA9IF9lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9lLCBfZiA9IF9hLmRpc2FibGVBYmJyZXZpYXRpb25zLCBkaXNhYmxlQWJicmV2aWF0aW9ucyA9IF9mID09PSB2b2lkIDAgPyBmYWxzZSA6IF9mLCBfZGVjaW1hbFNlcGFyYXRvciA9IF9hLmRlY2ltYWxTZXBhcmF0b3IsIF9ncm91cFNlcGFyYXRvciA9IF9hLmdyb3VwU2VwYXJhdG9yLCBvbkNoYW5nZSA9IF9hLm9uQ2hhbmdlLCBvbkZvY3VzID0gX2Eub25Gb2N1cywgb25CbHVyID0gX2Eub25CbHVyLCBvbktleURvd24gPSBfYS5vbktleURvd24sIG9uS2V5VXAgPSBfYS5vbktleVVwLCB0cmFuc2Zvcm1SYXdWYWx1ZSA9IF9hLnRyYW5zZm9ybVJhd1ZhbHVlLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiYWxsb3dEZWNpbWFsc1wiLCBcImFsbG93TmVnYXRpdmVWYWx1ZVwiLCBcImlkXCIsIFwibmFtZVwiLCBcImNsYXNzTmFtZVwiLCBcImN1c3RvbUlucHV0XCIsIFwiZGVjaW1hbHNMaW1pdFwiLCBcImRlZmF1bHRWYWx1ZVwiLCBcImRpc2FibGVkXCIsIFwibWF4TGVuZ3RoXCIsIFwidmFsdWVcIiwgXCJvblZhbHVlQ2hhbmdlXCIsIFwiZml4ZWREZWNpbWFsTGVuZ3RoXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJkZWNpbWFsU2NhbGVcIiwgXCJwcmVmaXhcIiwgXCJzdWZmaXhcIiwgXCJpbnRsQ29uZmlnXCIsIFwic3RlcFwiLCBcIm1pblwiLCBcIm1heFwiLCBcImRpc2FibGVHcm91cFNlcGFyYXRvcnNcIiwgXCJkaXNhYmxlQWJicmV2aWF0aW9uc1wiLCBcImRlY2ltYWxTZXBhcmF0b3JcIiwgXCJncm91cFNlcGFyYXRvclwiLCBcIm9uQ2hhbmdlXCIsIFwib25Gb2N1c1wiLCBcIm9uQmx1clwiLCBcIm9uS2V5RG93blwiLCBcIm9uS2V5VXBcIiwgXCJ0cmFuc2Zvcm1SYXdWYWx1ZVwiXSk7XG4gICAgaWYgKF9kZWNpbWFsU2VwYXJhdG9yICYmIGlzTnVtYmVyKF9kZWNpbWFsU2VwYXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY2ltYWxTZXBhcmF0b3IgY2Fubm90IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuICAgIGlmIChfZ3JvdXBTZXBhcmF0b3IgJiYgaXNOdW1iZXIoX2dyb3VwU2VwYXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dyb3VwU2VwYXJhdG9yIGNhbm5vdCBiZSBhIG51bWJlcicpO1xuICAgIH1cbiAgICB2YXIgbG9jYWxlQ29uZmlnID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRMb2NhbGVDb25maWcoaW50bENvbmZpZyk7IH0sIFtpbnRsQ29uZmlnXSk7XG4gICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPSBfZGVjaW1hbFNlcGFyYXRvciB8fCBsb2NhbGVDb25maWcuZGVjaW1hbFNlcGFyYXRvciB8fCAnJztcbiAgICB2YXIgZ3JvdXBTZXBhcmF0b3IgPSBfZ3JvdXBTZXBhcmF0b3IgfHwgbG9jYWxlQ29uZmlnLmdyb3VwU2VwYXJhdG9yIHx8ICcnO1xuICAgIGlmIChkZWNpbWFsU2VwYXJhdG9yICYmXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yICYmXG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3IgPT09IGdyb3VwU2VwYXJhdG9yICYmXG4gICAgICAgIGRpc2FibGVHcm91cFNlcGFyYXRvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVjaW1hbFNlcGFyYXRvciBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgZ3JvdXBTZXBhcmF0b3InKTtcbiAgICB9XG4gICAgdmFyIGZvcm1hdFZhbHVlT3B0aW9ucyA9IHtcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogZGVjaW1hbFNlcGFyYXRvcixcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6IGdyb3VwU2VwYXJhdG9yLFxuICAgICAgICBkaXNhYmxlR3JvdXBTZXBhcmF0b3JzOiBkaXNhYmxlR3JvdXBTZXBhcmF0b3JzLFxuICAgICAgICBpbnRsQ29uZmlnOiBpbnRsQ29uZmlnLFxuICAgICAgICBwcmVmaXg6IHByZWZpeCB8fCBsb2NhbGVDb25maWcucHJlZml4LFxuICAgICAgICBzdWZmaXg6IHN1ZmZpeCxcbiAgICB9O1xuICAgIHZhciBjbGVhblZhbHVlT3B0aW9ucyA9IHtcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogZGVjaW1hbFNlcGFyYXRvcixcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6IGdyb3VwU2VwYXJhdG9yLFxuICAgICAgICBhbGxvd0RlY2ltYWxzOiBhbGxvd0RlY2ltYWxzLFxuICAgICAgICBkZWNpbWFsc0xpbWl0OiBkZWNpbWFsc0xpbWl0IHx8IGZpeGVkRGVjaW1hbExlbmd0aCB8fCAyLFxuICAgICAgICBhbGxvd05lZ2F0aXZlVmFsdWU6IGFsbG93TmVnYXRpdmVWYWx1ZSxcbiAgICAgICAgZGlzYWJsZUFiYnJldmlhdGlvbnM6IGRpc2FibGVBYmJyZXZpYXRpb25zLFxuICAgICAgICBwcmVmaXg6IHByZWZpeCB8fCBsb2NhbGVDb25maWcucHJlZml4LFxuICAgICAgICB0cmFuc2Zvcm1SYXdWYWx1ZTogdHJhbnNmb3JtUmF3VmFsdWUsXG4gICAgfTtcbiAgICB2YXIgZm9ybWF0dGVkU3RhdGVWYWx1ZSA9IGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGRlZmF1bHRWYWx1ZSAhPT0gbnVsbFxuICAgICAgICA/IGZvcm1hdFZhbHVlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBmb3JtYXRWYWx1ZU9wdGlvbnMpLCB7IGRlY2ltYWxTY2FsZTogZGVjaW1hbFNjYWxlLCB2YWx1ZTogU3RyaW5nKGRlZmF1bHRWYWx1ZSkgfSkpXG4gICAgICAgIDogdXNlclZhbHVlICE9PSB1bmRlZmluZWQgJiYgdXNlclZhbHVlICE9PSBudWxsXG4gICAgICAgICAgICA/IGZvcm1hdFZhbHVlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBmb3JtYXRWYWx1ZU9wdGlvbnMpLCB7IGRlY2ltYWxTY2FsZTogZGVjaW1hbFNjYWxlLCB2YWx1ZTogU3RyaW5nKHVzZXJWYWx1ZSkgfSkpXG4gICAgICAgICAgICA6ICcnO1xuICAgIHZhciBfZyA9IHVzZVN0YXRlKGZvcm1hdHRlZFN0YXRlVmFsdWUpLCBzdGF0ZVZhbHVlID0gX2dbMF0sIHNldFN0YXRlVmFsdWUgPSBfZ1sxXTtcbiAgICB2YXIgX2ggPSB1c2VTdGF0ZShmYWxzZSksIGRpcnR5ID0gX2hbMF0sIHNldERpcnR5ID0gX2hbMV07XG4gICAgdmFyIF9qID0gdXNlU3RhdGUoMCksIGN1cnNvciA9IF9qWzBdLCBzZXRDdXJzb3IgPSBfalsxXTtcbiAgICB2YXIgX2sgPSB1c2VTdGF0ZSgwKSwgY2hhbmdlQ291bnQgPSBfa1swXSwgc2V0Q2hhbmdlQ291bnQgPSBfa1sxXTtcbiAgICB2YXIgX2wgPSB1c2VTdGF0ZShudWxsKSwgbGFzdEtleVN0cm9rZSA9IF9sWzBdLCBzZXRMYXN0S2V5U3Ryb2tlID0gX2xbMV07XG4gICAgdmFyIGlucHV0UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dFJlZi5jdXJyZW50OyB9KTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGNoYW5nZSBpbiB2YWx1ZVxuICAgICAqL1xuICAgIHZhciBwcm9jZXNzQ2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlLCBzZWxlY3Rpb25TdGFydCkge1xuICAgICAgICBzZXREaXJ0eSh0cnVlKTtcbiAgICAgICAgdmFyIF9hID0gcmVwb3NpdGlvbkN1cnNvcih7XG4gICAgICAgICAgICBzZWxlY3Rpb25TdGFydDogc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBsYXN0S2V5U3Ryb2tlOiBsYXN0S2V5U3Ryb2tlLFxuICAgICAgICAgICAgc3RhdGVWYWx1ZTogc3RhdGVWYWx1ZSxcbiAgICAgICAgICAgIGdyb3VwU2VwYXJhdG9yOiBncm91cFNlcGFyYXRvcixcbiAgICAgICAgfSksIG1vZGlmaWVkVmFsdWUgPSBfYS5tb2RpZmllZFZhbHVlLCBjdXJzb3JQb3NpdGlvbiA9IF9hLmN1cnNvclBvc2l0aW9uO1xuICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBjbGVhblZhbHVlKF9fYXNzaWduKHsgdmFsdWU6IG1vZGlmaWVkVmFsdWUgfSwgY2xlYW5WYWx1ZU9wdGlvbnMpKTtcbiAgICAgICAgaWYgKHVzZXJNYXhMZW5ndGggJiYgc3RyaW5nVmFsdWUucmVwbGFjZSgvLS9nLCAnJykubGVuZ3RoID4gdXNlck1heExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgfHwgc3RyaW5nVmFsdWUgPT09ICctJyB8fCBzdHJpbmdWYWx1ZSA9PT0gZGVjaW1hbFNlcGFyYXRvcikge1xuICAgICAgICAgICAgb25WYWx1ZUNoYW5nZSAmJiBvblZhbHVlQ2hhbmdlKHVuZGVmaW5lZCwgbmFtZSwgeyBmbG9hdDogbnVsbCwgZm9ybWF0dGVkOiAnJywgdmFsdWU6ICcnIH0pO1xuICAgICAgICAgICAgc2V0U3RhdGVWYWx1ZShzdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICAvLyBBbHdheXMgc2V0cyBjdXJzb3IgYWZ0ZXIgJy0nIG9yIGRlY2ltYWxTZXBhcmF0b3IgaW5wdXRcbiAgICAgICAgICAgIHNldEN1cnNvcigxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyaW5nVmFsdWVXaXRob3V0U2VwYXJhdG9yID0gZGVjaW1hbFNlcGFyYXRvclxuICAgICAgICAgICAgPyBzdHJpbmdWYWx1ZS5yZXBsYWNlKGRlY2ltYWxTZXBhcmF0b3IsICcuJylcbiAgICAgICAgICAgIDogc3RyaW5nVmFsdWU7XG4gICAgICAgIHZhciBudW1iZXJWYWx1ZSA9IHBhcnNlRmxvYXQoc3RyaW5nVmFsdWVXaXRob3V0U2VwYXJhdG9yKTtcbiAgICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gZm9ybWF0VmFsdWUoX19hc3NpZ24oeyB2YWx1ZTogc3RyaW5nVmFsdWUgfSwgZm9ybWF0VmFsdWVPcHRpb25zKSk7XG4gICAgICAgIGlmIChjdXJzb3JQb3NpdGlvbiAhPT0gdW5kZWZpbmVkICYmIGN1cnNvclBvc2l0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGN1cnNvciBqdW1waW5nXG4gICAgICAgICAgICB2YXIgbmV3Q3Vyc29yID0gY3Vyc29yUG9zaXRpb24gKyAoZm9ybWF0dGVkVmFsdWUubGVuZ3RoIC0gdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld0N1cnNvciA9IG5ld0N1cnNvciA8PSAwID8gKHByZWZpeCA/IHByZWZpeC5sZW5ndGggOiAwKSA6IG5ld0N1cnNvcjtcbiAgICAgICAgICAgIHNldEN1cnNvcihuZXdDdXJzb3IpO1xuICAgICAgICAgICAgc2V0Q2hhbmdlQ291bnQoY2hhbmdlQ291bnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRTdGF0ZVZhbHVlKGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgICAgaWYgKG9uVmFsdWVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB7XG4gICAgICAgICAgICAgICAgZmxvYXQ6IG51bWJlclZhbHVlLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZDogZm9ybWF0dGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHN0cmluZ1ZhbHVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9uVmFsdWVDaGFuZ2Uoc3RyaW5nVmFsdWUsIG5hbWUsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBjaGFuZ2UgZXZlbnRcbiAgICAgKi9cbiAgICB2YXIgaGFuZGxlT25DaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hID0gZXZlbnQudGFyZ2V0LCB2YWx1ZSA9IF9hLnZhbHVlLCBzZWxlY3Rpb25TdGFydCA9IF9hLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICBwcm9jZXNzQ2hhbmdlKHZhbHVlLCBzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgIG9uQ2hhbmdlICYmIG9uQ2hhbmdlKGV2ZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBmb2N1cyBldmVudFxuICAgICAqL1xuICAgIHZhciBoYW5kbGVPbkZvY3VzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIG9uRm9jdXMgJiYgb25Gb2N1cyhldmVudCk7XG4gICAgICAgIHJldHVybiBzdGF0ZVZhbHVlID8gc3RhdGVWYWx1ZS5sZW5ndGggOiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGJsdXIgZXZlbnRcbiAgICAgKlxuICAgICAqIEZvcm1hdCB2YWx1ZSBieSBwYWRkaW5nL3RyaW1taW5nIGRlY2ltYWxzIGlmIHJlcXVpcmVkIGJ5XG4gICAgICovXG4gICAgdmFyIGhhbmRsZU9uQmx1ciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgIHZhciB2YWx1ZU9ubHkgPSBjbGVhblZhbHVlKF9fYXNzaWduKHsgdmFsdWU6IHZhbHVlIH0sIGNsZWFuVmFsdWVPcHRpb25zKSk7XG4gICAgICAgIGlmICh2YWx1ZU9ubHkgPT09ICctJyB8fCB2YWx1ZU9ubHkgPT09IGRlY2ltYWxTZXBhcmF0b3IgfHwgIXZhbHVlT25seSkge1xuICAgICAgICAgICAgc2V0U3RhdGVWYWx1ZSgnJyk7XG4gICAgICAgICAgICBvbkJsdXIgJiYgb25CbHVyKGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZml4ZWREZWNpbWFscyA9IGZpeGVkRGVjaW1hbFZhbHVlKHZhbHVlT25seSwgZGVjaW1hbFNlcGFyYXRvciwgZml4ZWREZWNpbWFsTGVuZ3RoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gcGFkVHJpbVZhbHVlKGZpeGVkRGVjaW1hbHMsIGRlY2ltYWxTZXBhcmF0b3IsIGRlY2ltYWxTY2FsZSAhPT0gdW5kZWZpbmVkID8gZGVjaW1hbFNjYWxlIDogZml4ZWREZWNpbWFsTGVuZ3RoKTtcbiAgICAgICAgdmFyIG51bWJlclZhbHVlID0gcGFyc2VGbG9hdChuZXdWYWx1ZS5yZXBsYWNlKGRlY2ltYWxTZXBhcmF0b3IsICcuJykpO1xuICAgICAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSBmb3JtYXRWYWx1ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZm9ybWF0VmFsdWVPcHRpb25zKSwgeyB2YWx1ZTogbmV3VmFsdWUgfSkpO1xuICAgICAgICBpZiAob25WYWx1ZUNoYW5nZSkge1xuICAgICAgICAgICAgb25WYWx1ZUNoYW5nZShuZXdWYWx1ZSwgbmFtZSwge1xuICAgICAgICAgICAgICAgIGZsb2F0OiBudW1iZXJWYWx1ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQ6IGZvcm1hdHRlZFZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFN0YXRlVmFsdWUoZm9ybWF0dGVkVmFsdWUpO1xuICAgICAgICBvbkJsdXIgJiYgb25CbHVyKGV2ZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBrZXkgZG93biBldmVudFxuICAgICAqXG4gICAgICogSW5jcmVhc2Ugb3IgZGVjcmVhc2UgdmFsdWUgYnkgc3RlcFxuICAgICAqL1xuICAgIHZhciBoYW5kbGVPbktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IGV2ZW50LmtleTtcbiAgICAgICAgc2V0TGFzdEtleVN0cm9rZShrZXkpO1xuICAgICAgICBpZiAoc3RlcCAmJiAoa2V5ID09PSAnQXJyb3dVcCcgfHwga2V5ID09PSAnQXJyb3dEb3duJykpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzZXRDdXJzb3Ioc3RhdGVWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHBhcnNlRmxvYXQodXNlclZhbHVlICE9PSB1bmRlZmluZWQgJiYgdXNlclZhbHVlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcodXNlclZhbHVlKS5yZXBsYWNlKGRlY2ltYWxTZXBhcmF0b3IsICcuJylcbiAgICAgICAgICAgICAgICA6IGNsZWFuVmFsdWUoX19hc3NpZ24oeyB2YWx1ZTogc3RhdGVWYWx1ZSB9LCBjbGVhblZhbHVlT3B0aW9ucykpKSB8fCAwO1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0ga2V5ID09PSAnQXJyb3dVcCcgPyBjdXJyZW50VmFsdWUgKyBzdGVwIDogY3VycmVudFZhbHVlIC0gc3RlcDtcbiAgICAgICAgICAgIGlmIChtaW4gIT09IHVuZGVmaW5lZCAmJiBuZXdWYWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiBuZXdWYWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmaXhlZExlbmd0aCA9IFN0cmluZyhzdGVwKS5pbmNsdWRlcygnLicpXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIoU3RyaW5nKHN0ZXApLnNwbGl0KCcuJylbMV0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcHJvY2Vzc0NoYW5nZShTdHJpbmcoZml4ZWRMZW5ndGggPyBuZXdWYWx1ZS50b0ZpeGVkKGZpeGVkTGVuZ3RoKSA6IG5ld1ZhbHVlKS5yZXBsYWNlKCcuJywgZGVjaW1hbFNlcGFyYXRvcikpO1xuICAgICAgICB9XG4gICAgICAgIG9uS2V5RG93biAmJiBvbktleURvd24oZXZlbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGtleSB1cCBldmVudFxuICAgICAqXG4gICAgICogTW92ZSBjdXJzb3IgaWYgdGhlcmUgaXMgYSBzdWZmaXggdG8gcHJldmVudCB1c2VyIHR5cGluZyBwYXN0IHN1ZmZpeFxuICAgICAqL1xuICAgIHZhciBoYW5kbGVPbktleVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXkgPSBldmVudC5rZXksIHNlbGVjdGlvblN0YXJ0ID0gZXZlbnQuY3VycmVudFRhcmdldC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgaWYgKGtleSAhPT0gJ0Fycm93VXAnICYmIGtleSAhPT0gJ0Fycm93RG93bicgJiYgc3RhdGVWYWx1ZSAhPT0gJy0nKSB7XG4gICAgICAgICAgICB2YXIgc3VmZml4XzEgPSBnZXRTdWZmaXgoc3RhdGVWYWx1ZSwgeyBncm91cFNlcGFyYXRvcjogZ3JvdXBTZXBhcmF0b3IsIGRlY2ltYWxTZXBhcmF0b3I6IGRlY2ltYWxTZXBhcmF0b3IgfSk7XG4gICAgICAgICAgICBpZiAoc3VmZml4XzEgJiYgc2VsZWN0aW9uU3RhcnQgJiYgc2VsZWN0aW9uU3RhcnQgPiBzdGF0ZVZhbHVlLmxlbmd0aCAtIHN1ZmZpeF8xLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0N1cnNvciA9IHN0YXRlVmFsdWUubGVuZ3RoIC0gc3VmZml4XzEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dFJlZi5jdXJyZW50LnNldFNlbGVjdGlvblJhbmdlKG5ld0N1cnNvciwgbmV3Q3Vyc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb25LZXlVcCAmJiBvbktleVVwKGV2ZW50KTtcbiAgICB9O1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHByZXZlbnQgY3Vyc29yIGp1bXBpbmcgaWYgZWRpdGluZyB2YWx1ZVxuICAgICAgICBpZiAoZGlydHkgJiZcbiAgICAgICAgICAgIHN0YXRlVmFsdWUgIT09ICctJyAmJlxuICAgICAgICAgICAgaW5wdXRSZWYuY3VycmVudCAmJlxuICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gaW5wdXRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaW5wdXRSZWYuY3VycmVudC5zZXRTZWxlY3Rpb25SYW5nZShjdXJzb3IsIGN1cnNvcik7XG4gICAgICAgIH1cbiAgICB9LCBbc3RhdGVWYWx1ZSwgY3Vyc29yLCBpbnB1dFJlZiwgZGlydHksIGNoYW5nZUNvdW50XSk7XG4gICAgLyoqXG4gICAgICogSWYgdXNlciBoYXMgb25seSBlbnRlcmVkIFwiLVwiIG9yIGRlY2ltYWwgc2VwYXJhdG9yLFxuICAgICAqIGtlZXAgdGhlIGNoYXIgdG8gYWxsb3cgdGhlbSB0byBlbnRlciBuZXh0IHZhbHVlXG4gICAgICovXG4gICAgdmFyIGdldFJlbmRlclZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodXNlclZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHVzZXJWYWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgc3RhdGVWYWx1ZSAhPT0gJy0nICYmXG4gICAgICAgICAgICAoIWRlY2ltYWxTZXBhcmF0b3IgfHwgc3RhdGVWYWx1ZSAhPT0gZGVjaW1hbFNlcGFyYXRvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZm9ybWF0VmFsdWVPcHRpb25zKSwgeyBkZWNpbWFsU2NhbGU6IGRpcnR5ID8gdW5kZWZpbmVkIDogZGVjaW1hbFNjYWxlLCB2YWx1ZTogU3RyaW5nKHVzZXJWYWx1ZSkgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZVZhbHVlO1xuICAgIH07XG4gICAgdmFyIGlucHV0UHJvcHMgPSBfX2Fzc2lnbih7IHR5cGU6ICd0ZXh0JywgaW5wdXRNb2RlOiAnZGVjaW1hbCcsIGlkOiBpZCxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsIG9uQ2hhbmdlOiBoYW5kbGVPbkNoYW5nZSwgb25CbHVyOiBoYW5kbGVPbkJsdXIsIG9uRm9jdXM6IGhhbmRsZU9uRm9jdXMsIG9uS2V5RG93bjogaGFuZGxlT25LZXlEb3duLCBvbktleVVwOiBoYW5kbGVPbktleVVwLCBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsXG4gICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCwgdmFsdWU6IGdldFJlbmRlclZhbHVlKCksIHJlZjogaW5wdXRSZWYgfSwgcHJvcHMpO1xuICAgIGlmIChjdXN0b21JbnB1dCkge1xuICAgICAgICB2YXIgQ3VzdG9tSW5wdXQgPSBjdXN0b21JbnB1dDtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ3VzdG9tSW5wdXQsIF9fYXNzaWduKHt9LCBpbnB1dFByb3BzKSk7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgX19hc3NpZ24oe30sIGlucHV0UHJvcHMpKTtcbn0pO1xuQ3VycmVuY3lJbnB1dC5kaXNwbGF5TmFtZSA9ICdDdXJyZW5jeUlucHV0JztcblxuZXhwb3J0IGRlZmF1bHQgQ3VycmVuY3lJbnB1dDtcbmV4cG9ydCB7IGZvcm1hdFZhbHVlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-currency-input-field/dist/index.esm.js\n");

/***/ })

};
;